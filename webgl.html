<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>YKF2YVR</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	

	<body>
		<script src="js/three.js"></script>
		<script>
			var camera, scene, renderer;
			var cube;
			init();
			animate();
			
			function init() {
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				
				camera.position.x = 200*Math.cos(7*Math.PI/4);
				camera.position.z = 200*Math.sin(7*Math.PI/4);
				camera.position.y = 800;
				scene = new THREE.Scene();

				
				var cubes = new Array(40);
				for (var i = 0; i < 40; i++) {
				  cubes[i] = new Array(40);
				}
				for(i = 0; i < 40; i++){
					for(j = 0; j < 40; j++){
					    if(j>i) {
							var weight = (j+i)*(j-i);
							weight = (weight > 60 ? 60: weight);
							var offset = (1/j*i)*3
							cubes[i][j] = Math.floor(Math.random() * weight + offset );
						}
					}
				}
				
				//flatten
				for(i = 0; i < 40; i++){
					for(j = 0; j < 40; j++){
					    if(j>i) {
							var connectRow = Math.floor(Math.random() +0.5 );
							var connectColumn;
							if (connectRow && i > 0) {
								cubes[i][j] = cubes[i-1][j];
							}
							else {
								connectColumn = Math.floor(Math.random() +0.5 );
								if (connectColumn && j > 0) {
									cubes[i][j] = cubes[i][j-1];
								} 
							}
							if (!(connectRow||connectColumn) && i > 10 && j > 10) {
								cubes[i][j] = Math.floor((cubes[i][j] + cubes[i-1][j] + cubes[i][j-1]+ cubes[i+1][j] + cubes[i][j+1])/5);
							}
						}
					}
				}
				
				
				for(i = 0; i < 40; i++){
					for(j = 0; j < 40; j++){
					    if(j>i) {
							//create a cube, set its colour and add it to the scene.
							var material = new THREE.MeshPhongMaterial( { color: 0x33434C }  );
							var geometry = new THREE.BoxBufferGeometry( 20, 20*cubes[i][j], 20 );
							cube  = new THREE.Mesh( geometry, material );
							cube.position.x = (i*20-400);
							cube.position.z = (j*20-400);
							cube.position.y = (10*cubes[i][j]);
							scene.add( cube );
						}
					}
				}

				
				// Create a light, set its position, and add it to the scene.
				var ambientLight = new THREE.AmbientLight(0xffffff, 0.2)
				scene.add(ambientLight);
				
				// Create a light, set its position, and add it to the scene.
				var directionalLight = new THREE.DirectionalLight( 0xD3D3BD, 1 );
				directionalLight.position.set( 50, 100, 50 );
				scene.add(directionalLight);
	  
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor(new THREE.Color( 0x808080 ), 1);
				document.body.appendChild( renderer.domElement );
				
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				//camera.position.x = 2*Math.cos(delta);
				//camera.position.z = 2*Math.sin(delta);
				camera.lookAt(new THREE.Vector3( 0, 700, 0 ))
				renderer.render( scene, camera );
				//delta += 0.02;
			}
		</script>
	</body>
</html>